#!markdown

# Examples for the ``Informedica.GenSolver.Lib`` library

#!markdown

First load all required references and source files.

#!fsharp

#load "../Scripts/load.fsx"

#!markdown

Do some preprocessing.

#!fsharp

open Informedica.GenSolver.Lib
open Informedica.Utils.Lib.BCL
open Informedica.GenSolver.Utils
open MathNet.Numerics
open Types

module Api = Informedica.GenSolver.Lib.Api
module Solver = Informedica.GenSolver.Lib.Solver
module Name = Variable.Name
module ValueRange = Variable.ValueRange

let procss s = $"{s} " |> printfn "%s"

type Logger = Types.Logging.Logger

let printEqs = Solver.printEqs true procss
let solve n p eqs =
    let logger = { Logger.Log = ignore }
    let n = n |> Name.createExc
    Api.solve id logger None n p eqs
//    |> fun eqs -> eqs |> printEqs |> printfn "%A"; eqs

let init     = Api.init
let nonZeroNegative = Api.nonZeroNegative

#!markdown

## Variables, equations and notation

#!markdown

The solver will "solve" an ``Equation`` or a set of equations. An equation can be either a product equation or a sum equation of ``Variables``. A ``Variable`` is identified with a name and can be constraint by:

- No constraint, i.e. the variable can be any rational number
- A lower and/or upper limit, i.e. the variable can be any rational number within the limits of a lower and/or upper limit. 
- A limit can be inclusive or exclusive corresponding with ``>=, >, <, <=``.
- Increments, i.e. the variable can only contain rational numbers that are a multiple of one of the increments. 
- A set of numbers, i.e. the variable can only be one of the set.

When a variable is constraint to just one rational number, that variable is considered solved. When a variable is not solved the variable can have an further limitation until the variable is solved.

A variable (with name a) is printed out as:

- ``a <..>``
- ``a <0..>``
- ``a [0..>``
- ``a <..3..>``
- ``a [1, 2, 3]``

When a variable is limited by, for example ``[0..5>``, then you can

- increase the lower limit to ad most, but excluding 5, 
- lower the upper limit to and including 0,
- set a value(-s) between >= 0 and < 5.

#!markdown

For example a very simple equation.

#!fsharp

let simpleEq = [ "a = b" ] |> init
simpleEq
|> printEqs |> ignore

#!markdown

First define a simple product equation: 

``a = b * c``

#!fsharp

let prodEq1 = 
    [
        "a = b * c"  
    ] 
    |> init
// print the equation
prodEq1 |> printEqs |> ignore

#!markdown

## Setting variables to single values

#!markdown

Variables can be set to a single value, each at a time. This will result in the calculation of dependent variables. This means the solver will look at the defined product equation 

``a = b * c`` 

as:

- ``a = b * c`` 
- ``b = a / c`` 
- ``c = a / b``

When both indepent variables in one of the equations above have a value or are in someway limited, the value or limitation is calculated for the dependent variable.

#!markdown

We set the variable ``b`` to 3.

#!fsharp

prodEq1
|> solve "b" (ValsProp ([3N] |> Set.ofList))
|> printEqs 
|> ignore

#!markdown

And value 2 to variable ``c``.

#!fsharp

prodEq1
|> solve "b" (ValsProp ([3N] |> Set.ofList))
|> solve "c" (ValsProp ([2N] |> Set.ofList))
|> printEqs 
|> ignore

#!markdown

Or we first set variable ``a`` to 6 and then, for example variable ``c`` to 2.

#!fsharp

prodEq1
|> solve "a" (ValsProp ([6N] |> Set.ofList))
|> solve "c" (ValsProp ([2N] |> Set.ofList))
|> printEqs 
|> ignore

#!markdown

## Setting variables to sets of values

#!markdown

Set the variable ``b`` to 1, 2, 3, 6.

#!fsharp

prodEq1
|> solve "b" (ValsProp ([1N; 2N; 3N; 6N] |> Set.ofList))
|> printEqs 
|> ignore

#!markdown

Set the variable ``c`` to 60, 120, 240, 500, 1000

#!fsharp

prodEq1
|> solve "b" (ValsProp ([1N; 2N; 3N; 6N] |> Set.ofList))
|> solve "c" (ValsProp ([60N; 120N; 240N; 500N; 1000N] |> Set.ofList))
|> printEqs 
|> ignore

#!markdown

Or set variable ``a`` to 60, 120, 180, 240, 360, 480, 500, 720, 1000, 1440, 1500, 2000, 3000, 6000.

#!fsharp

prodEq1
|> solve "b" (ValsProp ([1N; 2N; 3N; 6N] |> Set.ofList))
|> solve "a" (ValsProp ([60N; 120N; 180N; 240N; 360N; 480N; 500N; 720N; 1000N; 1440N; 1500N; 2000N; 3000N; 6000N] |> Set.ofList))
|> printEqs 
|> ignore

#!markdown

Then set variable ``c`` to 60, 120, 240, 500, 100.

#!fsharp

prodEq1
|> solve "b" (ValsProp ([1N; 2N; 3N; 6N] |> Set.ofList))
|> solve "a" (ValsProp ([60N; 120N; 180N; 240N; 360N; 480N; 500N; 720N; 1000N; 1440N; 1500N; 2000N; 3000N; 6000N] |> Set.ofList))
|> solve "c" (ValsProp ([60N; 120N; 240N; 500N; 1000N] |> Set.ofList))
|> printEqs 
|> ignore

#!markdown

## Setting upper and lower limits

#!markdown

Limit ``b`` with a minimum inclusive of 0.

#!fsharp

prodEq1
|> solve "b" (MinInclProp 0N)
|> printEqs 
|> ignore

#!markdown

Limit ``c`` as well to a minimum of inclusive 0

#!fsharp

prodEq1
|> solve "b" (MinInclProp 0N)
|> solve "c" (MinInclProp 0N)
|> printEqs 
|> ignore

#!markdown

Add a lower exclusive limit of 1 to ``a``.

#!fsharp

prodEq1
|> solve "b" (MinInclProp 0N)
|> solve "c" (MinInclProp 0N)
|> solve "a" (MinExclProp 1N)
|> printEqs 
|> ignore

#!markdown

Add an upper limit of exclusive 10 to ``a``.

#!fsharp

prodEq1
|> solve "b" (MinInclProp 0N)
|> solve "c" (MinInclProp 0N)
|> solve "a" (MinExclProp 1N)
|> solve "a" (MaxExclProp 10N)
|> printEqs 
|> ignore

#!markdown

Add an exlusive upper limit of 1 to ``c``.

#!fsharp

prodEq1
|> solve "b" (MinInclProp 0N)
|> solve "c" (MinInclProp 0N)
|> solve "a" (MinExclProp 1N)
|> solve "a" (MaxExclProp 10N)
|> solve "c" (MaxExclProp 1N)
|> printEqs 
|> ignore
