#!markdown

# Explore situations with division of increments

#!fsharp

#load "../Scripts/load.fsx"

open Informedica.GenSolver.Lib

#!markdown

### Setup the environment

#!fsharp

open Informedica.GenSolver.Lib
open Informedica.Utils.Lib.BCL
open MathNet.Numerics
open Types

module Api = Informedica.GenSolver.Lib.Api
module Solver = Informedica.GenSolver.Lib.Solver
module Name = Variable.Name
module ValueRange = Variable.ValueRange

let procss s = $"{s} " |> printfn "%s"

type Logger = Types.Logging.Logger

let printEqs msg = 
    printfn "%s" msg
    Solver.printEqs true procss

let solve n p eqs =
    let logger = { Logger.Log = ignore }
    let n = n |> Name.createExc
    Api.solve id logger None n p eqs
//    |> fun eqs -> eqs |> printEqs |> printfn "%A"; eqs


let setMinMax p v = 
    v
    |> BigRational.fromFloat
    |> function
    | Some br -> br |> p
    | None    -> $"{v} cannot be converted to BigRational" |> failwith

let setIncrVS p vs =
    vs
    |> List.choose BigRational.fromFloat
    |> Set.ofList
    |> p

let setMinIncl = setMinMax MinInclProp
let setMinExcl = setMinMax MinExclProp
let setMaxIncl = setMinMax MaxInclProp
let setMaxExcl = setMinMax MaxExclProp

let setIncr = setIncrVS IncrProp
let setValueSet = setIncrVS ValsProp


let init     = Api.init
let nonZeroNegative = Api.nonZeroNegative

#!markdown

### Define a simple product equation

#!fsharp

let eqs = 
    [
        "a = b * c"
    ]
    |> Api.init
    |> nonZeroNegative

#!fsharp

eqs
|> solve "a" (setMinIncl 1.)
|> solve "a" (setMaxIncl 5.)
|> solve "a" (setIncr [1.])
|> solve "c" (setMaxIncl 5.)
|> solve "c" (setMinIncl 1.)
|> solve "c" (setIncr [1.])
|> printEqs ""
|> ignore

#!fsharp

eqs
|> solve "a" (setMaxIncl 10.)
|> solve "a" (setIncr [1.])
|> solve "c" (setMaxIncl 10.)
|> solve "c" (setIncr [1.])
|> printEqs
|> ignore

#!fsharp

eqs
|> solve "a" (setMaxIncl 5.)
|> solve "a" (setIncr [1.])
|> solve "c" (setMaxIncl 5.)
|> solve "c" (setIncr [1.])
|> solve "a" (setValueSet [1. ..0.5 .. 5.])
|> solve "c" (setValueSet [1. .. 0.75 .. 5.])
|> printEqs ""
|> ignore

#!fsharp

List.allPairs [1N/2N..1N/2N..1N] [3N/4N..3N/4N..(6N/4N)] 
//|> fun xs -> xs |> List.iter (printfn "%A"); xs
|> List.map (fun (x1, x2) -> x1 / x2)
|> Set.ofSeq
|> fun xs -> printfn "before: "; xs |> Set.iter (printf "%A\n") ; xs
//|> fun xs -> xs |> Set.add ((3N/4N)) 
|> Set.removeBigRationalMultiples 
|> fun xs -> printfn "after: ";  xs |> (printfn "%A") ; xs
|> Set.count

#!fsharp

let nextSmallestStep min1 incr1 max2 incr2 min max =
    List.allPairs [min1..incr1..(min + incr1)] [(max - incr2)..incr2..max2] 
    |> List.sortBy (fun (x1, x2) -> x1 / x2)
    |> List.tryFind (fun (x1, x2) -> (x1 / x2) > (min/max)) 
    |> function
    | None            -> min, max
    | Some (min, max) -> min, max

let rec calcIncrDivisors min1 incr1 max1 min2 incr2 max2 =
    let next = nextSmallestStep min1 incr1 max2 incr2 
    let rec calc min max acc =
        match acc with
        | [] -> 
            let incr = min / max
            let min, max = next min max
            [incr]
            |> calc min max
        | h::tail ->
            let incr = min / max
            if incr |> BigRational.isMultiple h then acc
            else
                let min, max = next min max
                acc @ [incr]
                |> calc min max
    calc min1 max2 []

calcIncrDivisors (1N/2N) (1N/2N) (50N) (10N) (10N) (100N)
|> List.length
|> fun x -> printfn $"no = {x}"
// let test = smallestStep (1N/2N) (1N/2N) 3N (1N/3N) 
// test (1N/2N) (5N/3N)
// |> fun (min, max) -> 
//     printfn $"min: {min}, max: {max}"
//     printfn $"{min / max}"

#!fsharp

let calcKerim min1 incr1 max1 min2 incr2 max2 =
    let max = max2
    let rec calc max2 acc =
        if acc |> List.isEmpty then
            [min1 / max]
            |> calc (max2 - incr2)
        else
            if (min1 / max2) >= ((min1 + incr1) / max) then acc
            else
                acc @ [min1 / max2]
                |> calc (max2 - incr2)
    
    calc max2 []

calcKerim (1N/2N) (1N/2N) (50N) (1N/10N) (1N/10N) (100N)
|> List.length
|> fun x -> printfn $"no = {x}"

#!fsharp

let calcDivisorsOfIncrs  min1 incrs1 max1 min2 incrs2 max2 =
    [
        for incr1 in incrs1 do
            for incr2 in incrs2 do
                yield! calcKerim min1 incr1 max1 min2 incr2 max2
    ]
    |> Set.ofList

calcDivisorsOfIncrs (1N/2N) [(1N/2N); (3N/4N)] (50N) (1N/10N) [(1N/10N); (1N/3N)] (100N)
|> Set.count
|> fun x -> printfn $"no = {x}"

#!fsharp

List.allPairs [1N/2N..1N/2N..40N] [3N/4N..3N/4N..(6N/4N)] 
//|> fun xs -> xs |> List.iter (printfn "%A"); xs
|> List.map (fun (x1, x2) -> x1 * x2)
|> Set.ofSeq
|> fun xs -> printfn "before: "; xs |> Set.iter (printf "%A\n") ; xs
//|> fun xs -> xs |> Set.add ((3N/4N)) 
|> Set.removeBigRationalMultiples 
|> fun xs -> printfn "after: ";  xs |> (printfn "%A") ; xs
|> Set.count
